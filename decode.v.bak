`timescale 1us/100ns

`include "decode_logic"

module decode_register_select(a0, a1, a2, imm, func, en_jmp, en_uncond_jmp, en_branch, en_imm, en_reg_wr, en_mem_wr, ld_code, instr, clk, rst);
    
    // Leaving decode stage, immediate value (if there is one)
    output wire [31:0] imm;
    // Leaving decode stage, function value (if there is one)
    output wire [9:0] func;
    // Leaving decode stage, enables if a jump can be taken
    output wire en_jmp;
    // Leaving decode stage, enables unconditional jumps
    output wire en_uncond_jmp;
    // Leaving decode stage, enables unconditional jump relative to value in a register
    output wire en_rel_reg_jmp;
    // Leaving decode stage, enables if a branch is going to be be taken or not
    output wire en_branch;
    // Leaving decode stage, enables the use of immediates
    output wire en_imm;
    // Leaving decode stage, enables a write to the register
    output wire en_reg_wr;
    // Leaving decode stage, enables a write to memory
    output wire en_mem_wr;
    // Leaving decode stage, value that determines which value is put on the register write bus
    output wire [2:0] ld_code;
    // Leaving decode stage, output data from register file
    output wire [31:0] d0;
    output wire [31:0] d1;

    // From fetch stage, the fetched instruction
    input wire [31:0] instr;
    input wire clk, rst;
    input wire data_hazard;
    
    // Register identifier for computation
    wire [4:0] a0;
    wire [4:0] a1;
    wire [4:0] a2;

    // Decode Logic
    decode_logic dec (.a0(a0), .a1(a1), 
                  .a2(a2), .imm(imm), .func(func), 
                  .en_jmp(en_jmp), .en_uncond_jmp(en_uncond_jmp), 
                  .en_imm(en_imm), .en_reg_wr(en_reg_wr), .en_mem_wr(en_mem_wr), 
                  .en_rel_reg_jmp(en_rel_reg_jmp), .ld_code(ld_code), .instr(instr));
    // Register File
    reg_file regs (.a0(a0), .a1(a1), .a2(a2), .din(reg_out_bits), .reg_wr(en_reg_wr & data_hazard), .d0(d0), .d1(d1), .clk(clk), .rst(rst));

endmodule
